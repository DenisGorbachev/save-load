#!/usr/bin/env -S deno run --allow-read --allow-write --no-lock

import {parseArgs} from "jsr:@std/cli@1.0.13"
import {stringify} from "jsr:@libs/xml@7.0.3"
import remarkHeadingShift from "npm:remark-heading-shift@1.1.2"
import remarkParse from "npm:remark-parse@11.0.0"
import remarkStringify from "npm:remark-stringify@11.0.0"
import {unified} from "npm:unified@11.0.5"
import {extname} from "jsr:@std/path@1.1.4"

const args = parseArgs(Deno.args, {
  string: ["output"],
  alias: {
    output: "o",
  },
})

const rootUrl = new URL(".", import.meta.url)

const isMarkdownPath = (path: string) => path.toLowerCase().endsWith(".md")

const resolvePath = (path: string) => new URL(path, rootUrl)

const fileExists = async (path: string) => {
  try {
    await Deno.stat(resolvePath(path))
    return true
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      return false
    }
    throw error
  }
}

const shiftHeadings = async (markdown: string) => {
  const file = await unified()
    .use(remarkParse)
    .use(remarkHeadingShift, 1)
    .use(remarkStringify)
    .process(markdown)
  return String(file).trimEnd()
}

const renderCodeFile = (path: string, contents: string) => {
  const identifier = getLanguageIdentifier(path)
  const trimmed = contents.trimEnd()
  const fence = getFence(trimmed)
  const fenced = `${fence}${identifier}\n${trimmed}\n${fence}`
  return [`### ${path}`, fenced].join("\n\n")
}

const getFence = (contents: string) => {
  const matches = contents.match(/`+/g) ?? []
  const max = matches.reduce((current, match) => Math.max(current, match.length), 0)
  return "`".repeat(Math.max(3, max + 1))
}

const getLanguageIdentifier = (path: string) => {
  const extension = extname(path)
  switch (extension) {
    case ".ts":
      return "typescript"
    case ".rs":
      return "rust"
    case ".xml":
      return "xml"
    case ".toml":
      return "toml"
    default:
      throw new Error(`Could not get a language identifier for extension: ${extension}`)
  }
}

const renderXmlFile = (path: string, contents: string) =>
  stringify(
    {
      file: {
        path,
        contents: "\n" + contents,
      },
    },
    {
      format: {
        indent: "",
        breakline: 0,
      },
    },
  ).trimEnd()

const includeFile = async (path: string) => {
  const contents = await Deno.readTextFile(resolvePath(path))
  if (isMarkdownPath(path)) {
    return await shiftHeadings(contents)
  }
  return renderCodeFile(path, contents)
}

const includeFileIfExists = async (path: string) => {
  const exists = await fileExists(path)
  if (!exists) {
    return null
  }
  return await includeFile(path)
}

const parts = (await Promise.all([
  Promise.resolve("<!-- This file is autogenerated by AGENTS.ts -->"),
  Promise.resolve("# Guidelines"),
  includeFile(".agents/general.md"),
  includeFileIfExists(".agents/project.md"),
  includeFileIfExists(".agents/knowledge.md"),
  includeFileIfExists(".agents/gotchas.md"),
  includeFile(".agents/error-handling.md"),
  Promise.resolve("## Project files"),
  includeFile("Cargo.toml"),
  includeFileIfExists("src/main.rs"),
  includeFileIfExists("src/lib.rs"),
])).filter((part): part is string => !!part && part.length > 0)

const content = parts.join("\n\n")

if (args.output) {
  await Deno.writeTextFile(args.output, `${content}\n`)
  await Deno.chmod(args.output, 0o444)
} else {
  console.info(content)
}
